 
This is a set of programs to implement Fig-FORTH on an Arduino MEGA2560/1280 SBC. It brings together two applications with a third being used to provide the function of an 
"intersticial glue". The infrastructure of the language, its headers and linked lists, are provided by TASM run on dosemu. The code for the Arduino is provided by the Arduino
IDE. It is basically C++. The file translation between the two is accomplished by gforth. 

There was a brief problem getting dosemu to work; it was shutting down after complaining of not being able to find the CD drive. I fixed this by making a symbolic link (sl) in the /media 
directory. Instructions on making symbolic links abound on the internet. I used "sudo sl name-of-thing-needed name-of-thing-to-be-linked-to". I originally used dosbox for running TASM
but after trying dosemu and finding it literally orders of magnitude faster I will not be going back.

The output file used by TASM is intel hex. A sample of it looks like this:
:1000000020000D970D8A0101610E1344000893C072
:10001000001F000F9340001F0000800080000D04AF
:1000200032E34A0C0000000000004669676475690D
:100030006E6F0000000000000000000000000000E3
and there is 16k of it that needs to be placed in an array (functioning as the SYSTEM ROM) in the Arduino's FLASH. This format can't be compiled directly and so had to be translated into
a form that would work for it. I elected to make an external Ardufigo.h file containing the array that was invoked by the Ardufigo.ino file. The Ardufigo.h file was translated from the 
Ardufigo.obj file which was generated by TASM. An excerpt looks like this:
const byte body[16384]  PROGMEM = {
0x20, 0x00, 0x0D, 0x97, 0x0D, 0x8A, 0x01, 0x01, 0x61, 0x0E, 0x13, 0x44, 0x00, 0x08, 0x93, 0xC0, //  .......a..D....
0x00, 0x1F, 0x00, 0x0F, 0x93, 0x40, 0x00, 0x1F, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x0D, 0x04, // .....@..........
0x32, 0xE3, 0x4A, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x69, 0x67, 0x64, 0x75, 0x69, // 2.J.......Figdui
0x6E, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // no..............
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ................
0x83, 0x4C, 0x49, 0x54, 0x00, 0x00, 0x01, 0x08, 0x00, 0x1B, 0x87, 0x45, 0x58, 0x45, 0x43, 0x55, // .LIT.......EXECU
0x54, 0x45, 0x01, 0x00, 0x01, 0x16, 0x00, 0x27, 0x86, 0x42, 0x52, 0x41, 0x4E, 0x43, 0x48, 0x01, // TE.....'.BRANCH.
0x0A, 0x01, 0x23, 0x00, 0x19, 0x87, 0x30, 0x42, 0x52, 0x41, 0x4E, 0x43, 0x48, 0x01, 0x18, 0x00, // ..#...0BRANCH...
0x1A, 0x86, 0x28, 0x4C, 0x4F, 0x4F, 0x50, 0x29, 0x01, 0x25, 0x01, 0x3C, 0x00, 0x39, 0x87, 0x28, // ..(LOOP).%.<.9.(
0x2B, 0x4C, 0x4F, 0x4F, 0x50, 0x29, 0x01, 0x31, 0x01, 0x4A, 0x00, 0x3A, 0x84, 0x28, 0x44, 0x4F, // +LOOP).1.J.:.(DO
0x29, 0x01, 0x3E, 0x01, 0x55, 0x00, 0x16, 0x82, 0x3E, 0x4C, 0x01, 0x4C, 0x01, 0x5E, 0x00, 0x43, // ).>.U...>L.L.^.C
0x82, 0x4C, 0x3E, 0x01, 0x57, 0x01, 0x67, 0x00, 0x44, 0x82, 0x4C, 0x3E, 0x01, 0x60, 0x01, 0x70, // .L>.W.g.D.L>.`.p
0x00, 0x48, 0x81, 0x49, 0x01, 0x69, 0x01, 0x78, 0x00, 0x1E, 0x85, 0x44, 0x49, 0x47, 0x49, 0x54, // .H.I.i.x...DIGIT
0x01, 0x72, 0x01, 0x84, 0x00, 0x00, 0x86, 0x28, 0x46, 0x49, 0x4E, 0x44, 0x29, 0x01, 0x7A, 0x01, // .r.....(FIND).z.
As can easily be seen this code comes much closer to being readable and is also compilable by the Arduino IDE. 

All of these programs are integrated by a script file running each program in succession and copying intermediate file forms into appropriate
 directories.

   The text parsing model is causing problems that, while repeatable, do not admit to any ready solution I can fathom. I am sure it is simple, I have simply not devoted the time to fixing it. 
I am writing an auxillary
routine to 'glue' ENCLOSE and WORD.
ENCLOSE leaves 4 stack entries. The first number is an offset that is added to IN. The next two are subtracted from each other to
create the length byte and the count of characters that are to be moved to HERE.

   It turns out that the problem above was the result of not putting the delimiter on the stack before calling WORD. I am amazed that
it worked at all. 
There is another file type, the BLOCK file, that is source code run on a system that is actually operating. The BLOCK file consists of 1024 bytes of source code arranged in a 16 line by 64 column format. The source code it contains is the same as the code that can be interpreted a line at a time by the outer interpreter. Each of these blocks has a 1024 byte documentation block called a "shadow" block. The shadow block and the source block can be toggled back and forth with the ctl-S key.
Additonal features that I will add to this file system center around a FCB or "File Control Block". 
Assume there are 1024 source code blocks. There are necessarily 1024 shadow blocks as well. Each of these shadow blocks is associated with a source code block. That means 2048 1k blocks are reserved in this file system for the data and documentation. Each of these source/documentation pairs are referred to in the singular as a super block. In order for all of the standard editing features to be implemented in this scenario I propose to have byte pairs in the 2048 byte FCB in the form of duples. The duples will carry the information about which of the source/documentation blocks (SDBs) are consecutive members of a file. Imagine a simplified system with 16 SDBs and two files. Due to a large amount of editing there are two files and their individual SDBs are not in consecutive order. The actual order of the SDBs for file 1 is:
05, 09, 14, 02, 08, 06
That would mean that the data in the FCB duples 0, 1, 2, 3, and 4 would look like the following table.
Address  -  Data
00       -  not used by block series generator
01       -  FFFF == unused
02       -  0008 
03       -  FFFF
04       -  FFFF
05       -  0009
06       -  0000 <-- End Of File
07       -  FFFF
08       -  0006  
09       -  000E
0A       -  FFFF
0B       -  FFFF
0C       -  FFFF
0D       -  FFFF
0E       -  0002
0F -     -  FFFF

In order to load the file starting at SDB 5 you would type "5 LOAD" and the block series generator would generate the appropriate block numbers and load the appropriate blocks in the proper order. It would also be able to generate pseudo block numbers so that the blocks appear, from a programming standpoint, to be consecutive.

pseudo    actual
0001   -   0005
0002   -   0009
0003   -   000E
0004   -   0002
0005   -   0008
0006   -   0006

Now for editing using block-sized entities. Suppose you want to insert a block between pseudo-blocks 3 and 4. actual block numbers are 14 and 2. The allocator scans the FCB looking for FFFF which means that block is unallocated. It takes the number of that block (in this case 0001) and writes that into 'address' 0014. So now 0014 contains 0001. 0001's FCB entry becomes 0002 and the new block series generator will produce the sequence:
  
pseudo    actual
0001   -   0005
0002   -   0009
0003   -   000E
0004   -   0001
0005   -   0002
0006   -   0008
0007   -   0006

Suppose the block at pseudo address 5 is to be deleted. What that means is actual block 1 will now be connected to actual block 8 and FFFF will be written into the location at actual block 2. The raw FCB table now looks like this:

Address  -  Data
00       -  not used by block series generator
01       -  0008
02       -  FFFF 
03       -  FFFF
04       -  FFFF
05       -  0009
06       -  0000 <-- End Of File
07       -  FFFF
08       -  0006  
09       -  000E
0A       -  FFFF
0B       -  FFFF
0C       -  FFFF
0D       -  FFFF
0E       -  0001
0F -     -  FFFF

This neatly circumvents the tedious problem of conveying big sections of data across multi-block boundaries. 

The next layer of abstraction is one of implementing file names. It is convenient to refer to a collection of blocks that comprise a single program by a symbolic name. For example let's call the program above PRIMA. PRIMA is a simple value initially containing the number 5. If that 5 changes to something else the OS will change the value in the body of PRIMA. This will allow the user to type PRIMA LOAD and the LOAD series generator will take care of the proper load order for the blocks. 